================================================================================
                 PROXIMITY BACKEND - EXPLORATION SUMMARY
================================================================================

GENERATED: 2024-10-29
EXPLORER: Claude Code (File Search Specialist)
THOROUGHNESS: COMPREHENSIVE (all apps, APIs, models, error handling explored)

================================================================================
                              KEY FINDINGS
================================================================================

1. ARCHITECTURE PATTERN
   - Multi-app Django 5.0 project with clean separation of concerns
   - Django Ninja for async-first API (typed, OpenAPI-documented)
   - Service layer pattern (ProxmoxService, PortManagerService, CatalogService)
   - Celery + Redis for async task processing (deployment, backups, cloning)

2. AUTHENTICATION SYSTEM
   - JWT tokens in HttpOnly cookies (proximity-auth-cookie)
   - Generated by simple-jwt, managed by dj-rest-auth
   - Global auth required (JWTCookieAuthenticator middleware)
   - Admin-only endpoints check request.auth.is_staff
   - User ownership isolation for non-admin users

3. CORE DOMAINS
   - Core: Users, system settings, health checks
   - Proxmox: Host/node management with connection pooling
   - Applications: Deployment lifecycle (deploy, clone, adopt)
   - Backups: Snapshot creation/restore/deletion
   - Catalog: Application templates (JSON-based, no DB models)

4. API DESIGN
   - RESTful endpoints with Django Ninja routers
   - Request validation via Pydantic schemas
   - Response codes: 200 (sync), 201 (created), 202 (async accepted), 4xx/5xx errors
   - Async tasks return 202 with polling mechanism
   - Error responses include status and descriptive messages

5. DEPLOYMENT FLOW
   POST /api/apps/ → Create Application record → Queue Celery task →
   Return 201 (deploying) → Task creates LXC, configures, starts →
   Update Application.status = 'running', lxc_id = VMID

6. ERROR HANDLING
   - ProxmoxError custom exception for Proxmox API failures
   - HttpError responses (400, 403, 404, 409, 500, 503)
   - Deployment logging (step-by-step tracking)
   - Celery task retries with exponential backoff
   - Sentry integration with event filtering

7. DATABASE MODELS
   - 8 main models: User, SystemSettings, ProxmoxHost, ProxmoxNode,
     Application, DeploymentLog, Backup
   - Foreign key relationships ensure data integrity
   - Singleton pattern for SystemSettings
   - Deployment logs track multi-step processes

8. ASYNC TASK PROCESSING
   - Celery with Redis broker (redis://redis:6379/0)
   - Periodic tasks: reconciliation (1h), janitor (6h)
   - Task families: deploy, start, stop, restart, delete, clone, adopt,
     backup-create, backup-restore, backup-delete

================================================================================
                           DOCUMENTATION FILES
================================================================================

1. BACKEND_ARCHITECTURE.md (1066 lines)
   - Complete API endpoint map with request/response examples
   - All database models with field descriptions
   - Error handling patterns and exception hierarchy
   - Authentication & authorization flow
   - Service layer architecture (ProxmoxService, PortManagerService, CatalogService)
   - Celery task configuration and periodic tasks
   - Monitoring & observability setup (Sentry, logging)
   - Design patterns and quick reference workflows
   - Full file reference guide

2. BACKEND_QUICK_REFERENCE.md
   - Fact sheet (framework, auth, task queue, database)
   - API endpoints grouped by domain
   - Database models quick map
   - Response codes reference
   - Deployment and backup flows
   - Common patterns and code examples
   - Configuration checklist for production
   - File locations quick reference

3. BACKEND_SUMMARY.txt (this file)
   - High-level exploration findings
   - Directory structure overview
   - Django apps summary
   - Key statistics and metrics

================================================================================
                         DJANGO APPS BREAKDOWN
================================================================================

CORE APP (User, Settings, Health)
├── Models: User, SystemSettings
├── Endpoints: 7 (health, system/info, settings/resources x2, settings/network x2)
├── Key Features:
│   - User authentication integration
│   - System resource/network defaults (singleton)
│   - Feature flags (AI agent, community chat, multi-host)
│   - Health check with DB/cache verification
│   - Admin-only settings updates

PROXMOX APP (Host & Node Management)
├── Models: ProxmoxHost, ProxmoxNode
├── Endpoints: 9 (list/create/read/update/delete hosts, test, sync, list nodes)
├── Key Features:
│   - Multi-host support (default host selection)
│   - Connection pooling (ProxmoxAPI cached in Redis)
│   - Node status tracking (online/offline)
│   - Resource monitoring (CPU, memory, storage)
│   - ProxmoxError exception handling

APPLICATIONS APP (Core Business Logic)
├── Models: Application, DeploymentLog
├── Endpoints: 8 (list, create, read, action, clone, discover, adopt, logs)
├── Key Features:
│   - Smart node selection (best available memory)
│   - Port allocation (public 8000-9000, internal 80-9000)
│   - Deployment status tracking (deploying → running)
│   - Celery integration for long-running tasks
│   - Application cloning and container adoption
│   - Deployment audit logging
│   - User ownership isolation

BACKUPS APP (Snapshot Management)
├── Models: Backup
├── Endpoints: 7 (list, create, read, restore, delete, stats, nested under apps)
├── Key Features:
│   - Backup lifecycle (creating → completed)
│   - Multiple compression formats (zstd, gzip, lzo)
│   - Restore operations (async, destructive warning)
│   - Backup statistics aggregation (count, size, avg)
│   - Async task processing

CATALOG APP (Application Templates)
├── Models: None (JSON-based)
├── Endpoints: 7 (list, search, filter, categories, stats, reload, get)
├── Key Features:
│   - File-based catalog (JSON in /catalog_data/)
│   - In-memory caching with reload support
│   - Search across name, description, tags
│   - Category filtering
│   - Statistics (total apps, categories)
│   - No database models

MONITORING APP
├── Models: None
├── Endpoints: None
├── Key Features:
│   - Placeholder for future implementation

================================================================================
                        API ENDPOINTS SUMMARY (42 total)
================================================================================

Authentication (dj-rest-auth): 5 endpoints
  POST   /api/auth/login/
  POST   /api/auth/logout/
  POST   /api/auth/registration/
  GET    /api/auth/user/
  POST   /api/auth/token/refresh/

Core System: 7 endpoints
  GET    /api/core/health
  GET    /api/core/system/info
  GET    /api/core/sentry-debug/
  GET    /api/core/settings/resources
  POST   /api/core/settings/resources
  GET    /api/core/settings/network
  POST   /api/core/settings/network

Proxmox: 9 endpoints
  GET    /api/proxmox/hosts
  POST   /api/proxmox/hosts
  GET    /api/proxmox/hosts/{host_id}
  PUT    /api/proxmox/hosts/{host_id}
  DELETE /api/proxmox/hosts/{host_id}
  POST   /api/proxmox/hosts/{host_id}/test
  POST   /api/proxmox/hosts/{host_id}/sync-nodes
  GET    /api/proxmox/nodes

Applications: 8 endpoints
  GET    /api/apps/
  POST   /api/apps/
  GET    /api/apps/{app_id}
  POST   /api/apps/{app_id}/action
  POST   /api/apps/{app_id}/clone
  GET    /api/apps/discover
  POST   /api/apps/adopt
  GET    /api/apps/{app_id}/logs

Backups: 6 endpoints
  GET    /api/apps/{app_id}/backups
  POST   /api/apps/{app_id}/backups
  GET    /api/apps/{app_id}/backups/{backup_id}
  POST   /api/apps/{app_id}/backups/{backup_id}/restore
  DELETE /api/apps/{app_id}/backups/{backup_id}
  GET    /api/apps/{app_id}/backups/stats

Catalog: 7 endpoints
  GET    /api/catalog/
  GET    /api/catalog/{app_id}
  GET    /api/catalog/search
  GET    /api/catalog/category/{category}
  GET    /api/catalog/categories
  POST   /api/catalog/reload
  GET    /api/catalog/stats

================================================================================
                          DATABASE MODELS (8 total)
================================================================================

CORE APP (2 models):
  User
    ├── Extended AbstractUser
    ├── Fields: avatar, bio, preferred_theme
    └── Relationships: FK to SystemSettings (updated_by)

  SystemSettings
    ├── Singleton (pk=1)
    ├── Resource defaults: cpu_cores, memory_mb, disk_gb, swap_mb
    ├── Network defaults: subnet, gateway, dns_primary/secondary, bridge
    ├── Features: ai_agent, community_chat, multi_host
    └── GitOps: repo_path, auto_commit

PROXMOX APP (2 models):
  ProxmoxHost
    ├── Fields: name, host, port, ssh_port, user, password, verify_ssl
    ├── Status: is_active, is_default, last_seen
    ├── Resources: total_cpu, total_memory, total_storage
    └── Relationships: 1->N ProxmoxNode, FK created_by User

  ProxmoxNode
    ├── Fields: name, status (online/offline), node_type
    ├── Resources: cpu_count, cpu_usage, memory_total/used, storage_total/used
    ├── Network: ip_address, uptime, pve_version
    └── Unique: (host_id, name)

APPLICATIONS APP (2 models):
  Application
    ├── PK: id (custom, format: {catalog_id}-{uuid[:8]})
    ├── Status: deploying/cloning/running/stopped/error/updating/removing
    ├── LXC: lxc_id, lxc_root_password
    ├── Ports: public_port (8000-9000), internal_port (80-9000)
    ├── Config: config, ports, volumes, environment (JSON)
    └── Relationships: FK host (ProxmoxHost), FK owner (User)

  DeploymentLog
    ├── Fields: level (info/warning/error), message, step (stage name)
    ├── Timestamps: timestamp (indexed)
    └── Relationships: FK application (Application)

BACKUPS APP (1 model):
  Backup
    ├── Fields: file_name, storage_name, size (bytes)
    ├── Type: backup_type (snapshot/suspend/stop)
    ├── Compression: zstd/gzip/lzo
    ├── Status: creating/completed/failed/restoring/deleting
    ├── Error tracking: error_message
    └── Relationships: FK application (Application)

CATALOG APP (0 models):
  - File-based, no database models
  - JSON files in /catalog_data/ directory
  - In-memory cache with reload support

MONITORING APP (0 models):
  - Not implemented yet

================================================================================
                        ASYNC TASK PROCESSING
================================================================================

CELERY CONFIGURATION:
  Broker URL: redis://redis:6379/0
  Result Backend: redis://redis:6379/0
  Time Limit: 30 minutes per task
  Serialization: JSON (not pickle)

PERIODIC TASKS (Celery Beat):
  1. reconciliation_task
     ├── Schedule: Every 1 hour (3600 seconds)
     ├── Expires: 3000 seconds (50 minutes)
     └── Purpose: Clean up orphan applications

  2. janitor_task
     ├── Schedule: Every 6 hours (21600 seconds)
     ├── Expires: 20000 seconds (5.5 hours)
     └── Purpose: Remove stuck deployments

APPLICATION LIFECYCLE TASKS:
  deploy_app_task(bind=True, max_retries=3)
    ├── Input: app_id, catalog_id, hostname, host_id, node, config, env, owner_id
    ├── Steps: Allocate VMID → Create LXC → Configure → Start
    ├── Output: {success, app_id, vmid, hostname, status}
    └── Failure: Retry with backoff, set status='error'

  start_app_task / stop_app_task / restart_app_task
    ├── Single-step operations
    └── Update Application status

  delete_app_task
    ├── Deletes LXC container
    └── Removes Application record

  clone_app_task(source_app_id, new_hostname, owner_id)
    ├── Clones LXC container
    └── Creates new Application record

  adopt_app_task(payload)
    ├── Imports unmanaged container
    ├── Auto-detects or manual port specification
    └── Creates Application record

BACKUP TASKS:
  create_backup_task(application_id, backup_type, compression)
    └── Creates snapshot via Proxmox

  restore_backup_task(backup_id)
    └── Restores from snapshot (DESTRUCTIVE)

  delete_backup_task(backup_id)
    └── Deletes backup file

TASK STATUS PATTERN:
  API returns 202 Accepted → Task queued
  Client polls GET /api/apps/{app_id} or /api/apps/{app_id}/logs
  Task updates database → Client sees final state

================================================================================
                      ERROR HANDLING PATTERNS
================================================================================

EXCEPTION HIERARCHY:
  ProxmoxError (custom)
    ├── Authentication failures
    ├── Connection errors
    ├── Container lifecycle failures
    └── Snapshot operation failures

HTTP ERROR RESPONSES:
  400 Bad Request
    ├── Validation errors
    ├── Duplicate hostname
    └── Invalid CIDR/IP addresses

  403 Forbidden
    └── Admin privileges required

  404 Not Found
    ├── Resource doesn't exist
    └── Application not found

  409 Conflict
    ├── Duplicate hostname
    ├── Container already managed
    └── Operation already in progress

  500 Internal Server Error
    └── Unexpected failures

  503 Service Unavailable
    └── No online Proxmox nodes

HANDLING PATTERNS:
  1. API Endpoints:
     try/except with specific error handling
     Return HTTP error responses
     Log to Sentry on unexpected errors

  2. Celery Tasks:
     Comprehensive logging with log_deployment helper
     Exception handling with retry mechanism
     Status updates (deploying → running/error)
     Exponential backoff for retries

  3. Validation:
     Pydantic schema validation (automatic)
     CIDR validation using ipaddress module
     Hostname uniqueness check in database

  4. Monitoring:
     Sentry integration with user context
     Custom logging to console/stdout
     Deployment audit trail in database

================================================================================
                    KEY DESIGN PATTERNS IDENTIFIED
================================================================================

1. SINGLETON PATTERN
   - SystemSettings: Only one instance (pk=1) via .load() class method

2. SERVICE LAYER PATTERN
   - ProxmoxService: Wraps ProxmoxAPI with connection pooling, error handling
   - PortManagerService: Port allocation and availability checking
   - CatalogService: Load, search, filter catalog from JSON

3. ASYNC TASK PATTERN
   - Celery @shared_task for long-running operations
   - 202 Accepted responses with polling mechanism
   - Deployment logs track multi-step processes

4. TRANSACTION SAFETY
   - Two-phase commit: Create in DB first, queue task after commit
   - Prevents race condition: task runs before object exists

5. CONNECTION POOLING
   - ProxmoxAPI client cached in Redis for 5 minutes
   - Cache key: proxmox_client_{host_id}

6. SMART NODE SELECTION
   - Auto-select online node with most available memory
   - Fallback to first online node if memory info unavailable

7. GLOBAL AUTHENTICATION
   - JWTCookieAuthenticator middleware validates all requests
   - Exception: /health, /auth/* endpoints
   - User context via request.auth

8. ADMIN-ONLY CHECKS
   - Guard clauses: if not request.auth or not request.auth.is_staff
   - Settings updates and catalog reload require admin

9. USER OWNERSHIP ISOLATION
   - Non-admin users see only their own applications
   - queryset.filter(owner=request.user)

10. MIDDLEWARE FOR CROSS-CUTTING CONCERNS
    - SentryUserContextMiddleware: Enrich errors with user info
    - CorsMiddleware: CORS header handling
    - AuthenticationMiddleware: JWT validation

================================================================================
                     FILE ORGANIZATION SUMMARY
================================================================================

KEY DIRECTORY STRUCTURE:
  backend/
  ├── proximity/                    # Django project config
  │   ├── settings.py              # All Django & app configuration
  │   ├── urls.py                  # API route registration
  │   ├── auth.py                  # Custom JWT authentication
  │   ├── celery.py                # Celery setup, periodic tasks
  │   └── asgi.py, wsgi.py
  │
  ├── apps/                        # Django apps (business logic)
  │   ├── core/                    # Users, settings, health
  │   │   ├── models.py
  │   │   ├── api.py               # 7 endpoints
  │   │   ├── schemas.py
  │   │   └── middleware.py
  │   │
  │   ├── proxmox/                 # Host/node management
  │   │   ├── models.py
  │   │   ├── api.py               # 9 endpoints
  │   │   ├── services.py          # ProxmoxService
  │   │   └── schemas.py
  │   │
  │   ├── applications/            # App deployment
  │   │   ├── models.py
  │   │   ├── api.py               # 8 endpoints
  │   │   ├── tasks.py             # Celery tasks
  │   │   ├── services.py
  │   │   ├── port_manager.py
  │   │   └── schemas.py
  │   │
  │   ├── backups/                 # Backup/restore
  │   │   ├── models.py
  │   │   ├── api.py               # 6 endpoints
  │   │   ├── tasks.py
  │   │   └── schemas.py
  │   │
  │   ├── catalog/                 # Application catalog
  │   │   ├── api.py               # 7 endpoints
  │   │   ├── services.py          # CatalogService
  │   │   └── schemas.py
  │   │
  │   └── monitoring/              # (placeholder)
  │
  ├── tests/                       # Test suite
  ├── manage.py                    # Django CLI
  ├── requirements.txt             # Dependencies
  └── docker-compose.yml

CRITICAL FILES TO UNDERSTAND:
  1. settings.py - All configuration, installed apps, middleware, auth
  2. urls.py - API route registration and global auth setup
  3. auth.py - JWTCookieAuthenticator implementation
  4. celery.py - Celery config, beat schedule
  5. apps/*/api.py - API endpoint implementations
  6. apps/*/models.py - Database schema
  7. apps/applications/tasks.py - Main async operations
  8. apps/proxmox/services.py - Proxmox API wrapper

================================================================================
                         CONFIGURATION NOTES
================================================================================

ENVIRONMENT VARIABLES REQUIRED:
  Django:
    - DEBUG (False in production)
    - SECRET_KEY (strong random string)
    - ALLOWED_HOSTS (list of domains)
    - DATABASE_URL (PostgreSQL in production)

  Proxmox:
    - PROXMOX_HOST, PROXMOX_USER, PROXMOX_PASSWORD
    - PROXMOX_PORT (default: 8006)
    - PROXMOX_VERIFY_SSL (False for self-signed)

  Celery & Redis:
    - CELERY_BROKER_URL (redis://redis:6379/0)
    - CELERY_RESULT_BACKEND (redis://redis:6379/0)
    - REDIS_URL (redis://redis:6379/0)

  CORS:
    - CORS_ALLOWED_ORIGINS (http://localhost:5173)
    - CORS_ALLOW_CREDENTIALS (True)

  JWT:
    - REST_AUTH.JWT_AUTH_COOKIE ('proximity-auth-cookie')
    - REST_AUTH.JWT_AUTH_REFRESH_COOKIE ('proximity-refresh-cookie')

  Sentry:
    - SENTRY_DSN (https://...)
    - SENTRY_ENVIRONMENT (development/staging/production)

TESTING MODE:
  - TESTING_MODE=True or USE_MOCK_PROXMOX=1
  - Skips real Proxmox calls
  - Generates fake VMIDs (9000+)
  - Useful for E2E tests without Proxmox

================================================================================
                            STATISTICS
================================================================================

Code Metrics:
  - Django Apps: 6 (core, proxmox, applications, backups, catalog, monitoring)
  - Database Models: 8 (User, SystemSettings, ProxmoxHost, ProxmoxNode, 
                        Application, DeploymentLog, Backup)
  - API Endpoints: 42+ (auth: 5, core: 7, proxmox: 9, apps: 8, backups: 6, catalog: 7)
  - Celery Tasks: 9+ (deploy, start, stop, restart, delete, clone, adopt,
                      create_backup, restore_backup, delete_backup,
                      reconciliation, janitor)
  - Service Classes: 3 (ProxmoxService, PortManagerService, CatalogService)

Technology Stack:
  - Framework: Django 5.0
  - API Framework: Django Ninja
  - Authentication: dj-rest-auth + simple-jwt
  - Task Queue: Celery
  - Message Broker: Redis
  - Database: SQLite (dev) / PostgreSQL (prod)
  - Validation: Pydantic
  - Monitoring: Sentry
  - Proxmox Client: proxmoxer + paramiko (SSH)

================================================================================
                        EXPLORATION COMPLETION
================================================================================

Systematic exploration completed covering:
  [X] Django apps structure and purposes
  [X] All API endpoints (42+)
  [X] Request/response schemas (all documented)
  [X] Database models (8 models, relationships mapped)
  [X] Error handling patterns
  [X] Authentication & authorization (JWT, admin checks, ownership)
  [X] Async tasks (Celery configuration, periodic tasks)
  [X] Service layer (ProxmoxService, PortManagerService, CatalogService)
  [X] Middleware and cross-cutting concerns
  [X] Configuration and environment setup
  [X] Monitoring and observability (Sentry, logging)
  [X] Design patterns identified and documented

DOCUMENTATION GENERATED:
  1. BACKEND_ARCHITECTURE.md (1066 lines)
     - Comprehensive reference with code examples
     - Full API endpoint map with request/response details
     - Database schema documentation
     - Design patterns and workflows

  2. BACKEND_QUICK_REFERENCE.md
     - Quick lookup guide
     - API endpoints at a glance
     - Common tasks and workflows
     - Configuration checklist

  3. BACKEND_SUMMARY.txt (this file)
     - High-level findings
     - Statistics and metrics
     - Complete breakdown of each component

All documentation files located in: /Users/fab/GitHub/proximity/

================================================================================
